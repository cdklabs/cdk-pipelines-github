{
  "version": 3,
  "sources": ["index.ts"],
  "sourcesContent": ["// eslint-disable-next-line import/no-extraneous-dependencies\nimport { S3 } from 'aws-sdk';\n\nconst AUTO_DELETE_OBJECTS_TAG = 'aws-cdk:auto-delete-objects';\n\nconst s3 = new S3();\n\nexport async function handler(event: AWSLambda.CloudFormationCustomResourceEvent) {\n  switch (event.RequestType) {\n    case 'Create':\n      return;\n    case 'Update':\n      return onUpdate(event);\n    case 'Delete':\n      return onDelete(event.ResourceProperties?.BucketName);\n  }\n}\n\nasync function onUpdate(event: AWSLambda.CloudFormationCustomResourceEvent) {\n  const updateEvent = event as AWSLambda.CloudFormationCustomResourceUpdateEvent;\n  const oldBucketName = updateEvent.OldResourceProperties?.BucketName;\n  const newBucketName = updateEvent.ResourceProperties?.BucketName;\n  const bucketNameHasChanged = newBucketName != null && oldBucketName != null && newBucketName !== oldBucketName;\n\n  /* If the name of the bucket has changed, CloudFormation will try to delete the bucket\n     and create a new one with the new name. So we have to delete the contents of the\n     bucket so that this operation does not fail. */\n  if (bucketNameHasChanged) {\n    return onDelete(oldBucketName);\n  }\n}\n\n/**\n * Recursively delete all items in the bucket\n *\n * @param bucketName the bucket name\n */\nasync function emptyBucket(bucketName: string) {\n  const listedObjects = await s3.listObjectVersions({ Bucket: bucketName }).promise();\n  const contents = [...listedObjects.Versions ?? [], ...listedObjects.DeleteMarkers ?? []];\n  if (contents.length === 0) {\n    return;\n  }\n\n  const records = contents.map((record: any) => ({ Key: record.Key, VersionId: record.VersionId }));\n  await s3.deleteObjects({ Bucket: bucketName, Delete: { Objects: records } }).promise();\n\n  if (listedObjects?.IsTruncated) {\n    await emptyBucket(bucketName);\n  }\n}\n\nasync function onDelete(bucketName?: string) {\n  if (!bucketName) {\n    throw new Error('No BucketName was provided.');\n  }\n  if (!await isBucketTaggedForDeletion(bucketName)) {\n    process.stdout.write(`Bucket does not have '${AUTO_DELETE_OBJECTS_TAG}' tag, skipping cleaning.\\n`);\n    return;\n  }\n  try {\n    await emptyBucket(bucketName);\n  } catch (e) {\n    if (e.code !== 'NoSuchBucket') {\n      throw e;\n    }\n    // Bucket doesn't exist. Ignoring\n  }\n}\n\n/**\n * The bucket will only be tagged for deletion if it's being deleted in the same\n * deployment as this Custom Resource.\n *\n * If the Custom Resource is every deleted before the bucket, it must be because\n * `autoDeleteObjects` has been switched to false, in which case the tag would have\n * been removed before we get to this Delete event.\n */\nasync function isBucketTaggedForDeletion(bucketName: string) {\n  const response = await s3.getBucketTagging({ Bucket: bucketName }).promise();\n  return response.TagSet.some(tag => tag.Key === AUTO_DELETE_OBJECTS_TAG && tag.Value === 'true');\n}"],
  "mappings": "2FACA,KAAA,WAAA,QAAA,WAEM,wBAA0B,8BAE1B,GAAK,GAAI,WAAA,GAER,uBAAuB,MAAkD,QAC9E,OAAQ,MAAM,iBACP,SACH,WACG,SACH,MAAO,UAAS,WACb,SACH,MAAO,UAAQ,IAAC,MAAM,sBAAkB,MAAA,KAAA,OAAA,OAAA,GAAE,aAPhD,QAAA,QAAA,QAWA,wBAAwB,MAAkD,WACxE,KAAM,aAAc,MACd,cAAa,IAAG,YAAY,yBAAqB,MAAA,KAAA,OAAA,OAAA,GAAE,WACnD,cAAa,IAAG,YAAY,sBAAkB,MAAA,KAAA,OAAA,OAAA,GAAE,WAMtD,GAL6B,eAAiB,MAAQ,eAAiB,MAAQ,gBAAkB,cAM/F,MAAO,UAAS,eASpB,2BAA2B,WAAkB,WAC3C,KAAM,eAAgB,KAAM,IAAG,mBAAmB,CAAE,OAAQ,aAAc,UACpE,SAAW,CAAC,GAAA,IAAG,cAAc,YAAQ,MAAA,KAAA,OAAA,GAAI,GAAI,GAAA,IAAG,cAAc,iBAAa,MAAA,KAAA,OAAA,GAAI,IACrF,GAAI,SAAS,SAAW,EACtB,OAGF,KAAM,SAAU,SAAS,IAAI,AAAC,QAAiB,EAAE,IAAK,OAAO,IAAK,UAAW,OAAO,aACpF,KAAM,IAAG,cAAc,CAAE,OAAQ,WAAY,OAAQ,CAAE,QAAS,WAAa,UAEzE,gBAAa,KAAA,OAAb,cAAe,cACjB,KAAM,aAAY,YAItB,wBAAwB,WAAmB,CACzC,GAAI,CAAC,WACH,KAAM,IAAI,OAAM,+BAElB,GAAI,CAAC,KAAM,2BAA0B,YAAa,CAChD,QAAQ,OAAO,MAAM,yBAAyB;GAC9C,OAEF,GAAI,CACF,KAAM,aAAY,kBACX,EAAP,CACA,GAAI,EAAE,OAAS,eACb,KAAM,IAcZ,yCAAyC,WAAkB,CAEzD,MAAO,AADU,MAAM,IAAG,iBAAiB,CAAE,OAAQ,aAAc,WACnD,OAAO,KAAK,KAAO,IAAI,MAAQ,yBAA2B,IAAI,QAAU",
  "names": []
}
